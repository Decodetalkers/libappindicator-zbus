//! # D-Bus interface proxy for: `org.kde.StatusNotifierItem`
//!
//! This code was generated by `zbus-xmlgen` `5.1.0` from D-Bus introspection data.
//! Source: `Interface '/StatusNotifierItem' from service ':1.9087' on system bus`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
//! following zbus API can be used:
//!
//! * [`zbus::fdo::PropertiesProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PeerProxy`]
//!
//! Consequently `zbus-xmlgen` did not generate code for the above interfaces.
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,
use std::marker::PhantomData;

use zbus::{
    connection, interface,
    object_server::SignalEmitter,
    proxy,
    zvariant::{OwnedObjectPath, OwnedValue, Type, Value},
};

use crate::{dbusmenu::DBusMenuMin, status_notifier_watcher::StatusNotifierWatcherProxy};

#[derive(Clone, PartialEq, Type, OwnedValue, Value, Debug, Default)]
struct IconPixmap {
    width: i32,
    height: i32,
    data: Vec<u8>,
}

#[derive(Clone, PartialEq, Type, OwnedValue, Value, Default, Debug)]
struct ToolTip {
    icon: String,
    data: Vec<IconPixmap>,
    title: String,
    description: String,
}

pub trait StatusNotifierItem {
    type State;
    fn boot(&self) -> Self::State;
    fn id(&self) -> String;
    fn activate(&self, state: &mut Self::State, x: i32, y: i32) -> zbus::fdo::Result<()>;
    fn context_menu(&self, _state: &mut Self::State, _x: i32, _y: i32) -> zbus::fdo::Result<()> {
        Err(zbus::fdo::Error::NotSupported("Error".to_owned()))
    }
    fn scroll(
        &self,
        _state: &mut Self::State,
        _delta: i32,
        _orientation: &str,
    ) -> zbus::fdo::Result<()> {
        Err(zbus::fdo::Error::NotSupported("Error".to_owned()))
    }
    fn secondary_activate(
        &self,
        _state: &mut Self::State,
        _x: i32,
        _y: i32,
    ) -> zbus::fdo::Result<()> {
        Err(zbus::fdo::Error::NotSupported("Error".to_owned()))
    }
    fn icon_name(&self, _state: &Self::State) -> zbus::fdo::Result<String> {
        Err(zbus::fdo::Error::NotSupported("Error".to_owned()))
    }
}

pub trait BootFn<State> {
    fn boot(&self) -> State;
}

impl<T, State> BootFn<State> for T
where
    T: Fn() -> State,
{
    fn boot(&self) -> State {
        self()
    }
}

pub trait IdFn {
    fn id(&self) -> String;
}

impl<T> IdFn for T
where
    T: Fn() -> String,
{
    fn id(&self) -> String {
        self()
    }
}

pub trait ActivateFn<State> {
    fn activate(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()>;
}

impl<T, State> ActivateFn<State> for T
where
    T: Fn(&mut State, i32, i32) -> zbus::fdo::Result<()>,
{
    fn activate(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self(state, x, y)
    }
}
pub trait ScrollFn<State> {
    fn scroll(&self, state: &mut State, delta: i32, orientation: &str) -> zbus::fdo::Result<()>;
}

impl<T, State> ScrollFn<State> for T
where
    T: Fn(&mut State, i32, &str) -> zbus::fdo::Result<()>,
{
    fn scroll(&self, state: &mut State, delta: i32, orientation: &str) -> zbus::fdo::Result<()> {
        self(state, delta, orientation)
    }
}
pub trait SecondaryActivateFn<State> {
    fn secondary_activate(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()>;
}

impl<T, State> SecondaryActivateFn<State> for T
where
    T: Fn(&mut State, i32, i32) -> zbus::fdo::Result<()>,
{
    fn secondary_activate(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self(state, x, y)
    }
}

pub trait ContextMenuFn<State> {
    fn context_menu(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()>;
}

impl<T, State> ContextMenuFn<State> for T
where
    T: Fn(&mut State, i32, i32) -> zbus::fdo::Result<()>,
{
    fn context_menu(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self(state, x, y)
    }
}

pub struct Tray<P: StatusNotifierItem> {
    raw: P,
}

pub struct TrayConnection<P: StatusNotifierItem> {
    conn: zbus::Connection,
    _item: PhantomData<P>,
}

impl<P: StatusNotifierItem> TrayConnection<P>
where
    P::State: 'static + Send + Sync,
    P: Send + Sync + 'static,
{
    pub async fn update_state<F>(&self, f: F) -> zbus::Result<()>
    where
        F: Fn(&mut P::State),
    {
        let iface_ref = self
            .conn
            .object_server()
            .interface::<_, StatusNotifierInstance<P>>("/StatusNotifierItem")
            .await?;
        let mut data = iface_ref.get_mut().await;
        f(&mut data.state);
        Ok(())
    }
    pub fn unique_name(&self) -> Option<&zbus::names::OwnedUniqueName> {
        self.conn.unique_name()
    }
}

impl<P: StatusNotifierItem> Tray<P>
where
    P::State: 'static + Send + Sync,
    P: Send + Sync + 'static,
{
    pub async fn run(self) -> zbus::Result<TrayConnection<P>> {
        let state = self.raw.boot();

        let instance = StatusNotifierInstance {
            program: self.raw,
            state,
        };
        let conn = connection::Builder::session()?
            .serve_at("/StatusNotifierItem", instance)?
            .serve_at("/MenuBar", DBusMenuMin)?
            .build()
            .await?;
        let service = conn.unique_name().unwrap().to_string();
        StatusNotifierWatcherProxy::builder(&conn)
            .build()
            .await?
            .register_status_notifier_item(&service)
            .await?;
        Ok(TrayConnection {
            conn,
            _item: PhantomData,
        })
    }

    pub fn with_icon_name(
        self,
        f: impl Fn(&P::State) -> zbus::fdo::Result<String>,
    ) -> Tray<impl StatusNotifierItem<State = P::State>> {
        Tray {
            raw: with_icon_name(self.raw, f),
        }
    }

    pub fn with_scroll(
        self,
        f: impl ScrollFn<P::State>,
    ) -> Tray<impl StatusNotifierItem<State = P::State>> {
        Tray {
            raw: with_scroll(self.raw, f),
        }
    }

    pub fn with_secondary_activate(
        self,
        f: impl SecondaryActivateFn<P::State>,
    ) -> Tray<impl StatusNotifierItem<State = P::State>> {
        Tray {
            raw: with_secondary_activate(self.raw, f),
        }
    }

    pub fn with_context_menu(
        self,
        f: impl ContextMenuFn<P::State>,
    ) -> Tray<impl StatusNotifierItem<State = P::State>> {
        Tray {
            raw: with_context_menu(self.raw, f),
        }
    }
}

pub struct StatusNotifierInstance<P: StatusNotifierItem> {
    program: P,
    state: P::State,
}

#[interface(name = "org.kde.StatusNotifierItem")]
impl<P: StatusNotifierItem> StatusNotifierInstance<P>
where
    P: Send + Sync + 'static,
    P::State: 'static + Send + Sync,
{
    fn activate(&mut self, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self.program.activate(&mut self.state, x, y)
    }

    /// ContextMenu method
    fn context_menu(&mut self, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self.program.context_menu(&mut self.state, x, y)
    }

    fn scroll(&mut self, delta: i32, orientation: &str) -> zbus::fdo::Result<()> {
        self.program.scroll(&mut self.state, delta, orientation)
    }

    fn secondary_activate(&mut self, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self.program.secondary_activate(&mut self.state, x, y)
    }

    /// NewAttentionIcon signal
    #[zbus(signal)]
    async fn new_attention_icon(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewIcon signal
    #[zbus(signal)]
    async fn new_icon(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewMenu signal
    #[zbus(signal)]
    async fn new_menu(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewOverlayIcon signal
    #[zbus(signal)]
    async fn new_overlay_icon(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewStatus signal
    #[zbus(signal)]
    async fn new_status(ctxt: &SignalEmitter<'_>, status: &str) -> zbus::Result<()>;

    /// NewTitle signal
    #[zbus(signal)]
    async fn new_title(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewToolTip signal
    #[zbus(signal)]
    async fn new_tool_tip(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// Menu property
    #[zbus(property)]
    fn menu(&self) -> zbus::fdo::Result<zbus::zvariant::OwnedObjectPath> {
        Ok(OwnedObjectPath::try_from("/MenuBar").unwrap())
    }

    /// IconName property
    #[zbus(property)]
    fn icon_name(&self) -> zbus::fdo::Result<String> {
        self.program.icon_name(&self.state)
    }

    /// Id property
    #[zbus(property)]
    fn id(&self) -> zbus::fdo::Result<String> {
        Ok(self.program.id())
    }

    /// Status property
    #[zbus(property)]
    fn status(&self) -> zbus::fdo::Result<String> {
        Ok("Active".to_owned())
    }

    /// Title property
    #[zbus(property)]
    fn title(&self) -> zbus::fdo::Result<String> {
        Ok("test".to_owned())
    }
}

fn with_icon_name<P: StatusNotifierItem>(
    program: P,
    icon: impl Fn(&P::State) -> zbus::fdo::Result<String>,
) -> impl StatusNotifierItem<State = P::State>
where
    P::State: 'static + Send + Sync,
{
    struct WithTheme<P, F> {
        program: P,
        icon: F,
    }
    impl<P: StatusNotifierItem, F> StatusNotifierItem for WithTheme<P, F>
    where
        F: Fn(&P::State) -> zbus::fdo::Result<String>,
    {
        type State = P::State;

        fn id(&self) -> String {
            self.program.id()
        }
        fn boot(&self) -> Self::State {
            self.program.boot()
        }
        fn scroll(
            &self,
            state: &mut Self::State,
            delta: i32,
            orientation: &str,
        ) -> zbus::fdo::Result<()> {
            self.program.scroll(state, delta, orientation)
        }
        fn context_menu(&self, state: &mut Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.program.context_menu(state, x, y)
        }
        fn activate(&self, state: &mut Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.program.activate(state, x, y)
        }
        fn secondary_activate(
            &self,
            state: &mut Self::State,
            x: i32,
            y: i32,
        ) -> zbus::fdo::Result<()> {
            self.program.secondary_activate(state, x, y)
        }
        fn icon_name(&self, state: &Self::State) -> zbus::fdo::Result<String> {
            (self.icon)(state)
        }
    }
    WithTheme { program, icon }
}

fn with_context_menu<P: StatusNotifierItem>(
    program: P,
    context_menu: impl ContextMenuFn<P::State>,
) -> impl StatusNotifierItem<State = P::State>
where
    P::State: 'static + Send + Sync,
{
    struct WithContextMenu<P, ContextMenuFn> {
        program: P,
        context_menu: ContextMenuFn,
    }
    impl<P: StatusNotifierItem, ContextMenuFn> StatusNotifierItem for WithContextMenu<P, ContextMenuFn>
    where
        ContextMenuFn: self::ContextMenuFn<P::State>,
    {
        type State = P::State;

        fn id(&self) -> String {
            self.program.id()
        }
        fn boot(&self) -> Self::State {
            self.program.boot()
        }
        fn scroll(
            &self,
            state: &mut Self::State,
            delta: i32,
            orientation: &str,
        ) -> zbus::fdo::Result<()> {
            self.program.scroll(state, delta, orientation)
        }
        fn context_menu(&self, state: &mut Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.context_menu.context_menu(state, x, y)
        }
        fn activate(&self, state: &mut Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.program.activate(state, x, y)
        }
        fn secondary_activate(
            &self,
            state: &mut Self::State,
            x: i32,
            y: i32,
        ) -> zbus::fdo::Result<()> {
            self.program.secondary_activate(state, x, y)
        }
        fn icon_name(&self, state: &Self::State) -> zbus::fdo::Result<String> {
            self.program.icon_name(state)
        }
    }
    WithContextMenu {
        program,
        context_menu,
    }
}

fn with_scroll<P: StatusNotifierItem>(
    program: P,
    scroll: impl ScrollFn<P::State>,
) -> impl StatusNotifierItem<State = P::State>
where
    P::State: 'static + Send + Sync,
{
    struct WithScroll<P, ScrollFn> {
        program: P,
        scroll: ScrollFn,
    }
    impl<P: StatusNotifierItem, ScrollFn> StatusNotifierItem for WithScroll<P, ScrollFn>
    where
        ScrollFn: self::ScrollFn<P::State>,
    {
        type State = P::State;

        fn id(&self) -> String {
            self.program.id()
        }
        fn boot(&self) -> Self::State {
            self.program.boot()
        }
        fn scroll(
            &self,
            state: &mut Self::State,
            delta: i32,
            orientation: &str,
        ) -> zbus::fdo::Result<()> {
            self.scroll.scroll(state, delta, orientation)
        }
        fn context_menu(&self, state: &mut Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.program.context_menu(state, x, y)
        }
        fn activate(&self, state: &mut Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.program.activate(state, x, y)
        }
        fn secondary_activate(
            &self,
            state: &mut Self::State,
            x: i32,
            y: i32,
        ) -> zbus::fdo::Result<()> {
            self.program.secondary_activate(state, x, y)
        }
        fn icon_name(&self, state: &Self::State) -> zbus::fdo::Result<String> {
            self.program.icon_name(state)
        }
    }
    WithScroll { program, scroll }
}

fn with_secondary_activate<P: StatusNotifierItem>(
    program: P,
    secondary_activate: impl SecondaryActivateFn<P::State>,
) -> impl StatusNotifierItem<State = P::State>
where
    P::State: 'static + Send + Sync,
{
    struct WithSecondaryActive<P, SecondaryActivateFn> {
        program: P,
        secondary_activate: SecondaryActivateFn,
    }
    impl<P: StatusNotifierItem, SecondaryActivateFn> StatusNotifierItem
        for WithSecondaryActive<P, SecondaryActivateFn>
    where
        SecondaryActivateFn: self::SecondaryActivateFn<P::State>,
    {
        type State = P::State;

        fn id(&self) -> String {
            self.program.id()
        }
        fn boot(&self) -> Self::State {
            self.program.boot()
        }
        fn scroll(
            &self,
            state: &mut Self::State,
            delta: i32,
            orientation: &str,
        ) -> zbus::fdo::Result<()> {
            self.program.scroll(state, delta, orientation)
        }
        fn context_menu(&self, state: &mut Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.program.context_menu(state, x, y)
        }
        fn activate(&self, state: &mut Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.program.activate(state, x, y)
        }
        fn secondary_activate(
            &self,
            state: &mut Self::State,
            x: i32,
            y: i32,
        ) -> zbus::fdo::Result<()> {
            self.secondary_activate.secondary_activate(state, x, y)
        }
        fn icon_name(&self, state: &Self::State) -> zbus::fdo::Result<String> {
            self.program.icon_name(state)
        }
    }
    WithSecondaryActive {
        program,
        secondary_activate,
    }
}

pub fn tray<State>(
    boot: impl BootFn<State>,
    id: impl IdFn,
    activate: impl ActivateFn<State>,
) -> Tray<impl StatusNotifierItem<State = State>>
where
    State: 'static + Send + Sync,
{
    use std::marker::PhantomData;
    struct Instance<State, IdFn, BootFn, ActivateFn> {
        boot: BootFn,
        id: IdFn,
        activate: ActivateFn,
        _state: PhantomData<State>,
    }
    impl<State, IdFn, BootFn, ActivateFn> StatusNotifierItem
        for Instance<State, IdFn, BootFn, ActivateFn>
    where
        BootFn: self::BootFn<State>,
        IdFn: self::IdFn,
        ActivateFn: self::ActivateFn<State>,
    {
        type State = State;
        fn id(&self) -> String {
            self.id.id()
        }
        fn boot(&self) -> Self::State {
            self.boot.boot()
        }

        fn activate(&self, state: &mut Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.activate.activate(state, x, y)
        }
    }

    Tray {
        raw: Instance {
            boot,
            id,
            activate,
            _state: PhantomData,
        },
    }
}

#[proxy(
    interface = "org.kde.StatusNotifierItem",
    default_path = "/StatusNotifierItem"
)]
pub trait StatusNotifierItemBackend {
    /// AttentionIconName property
    #[zbus(property)]
    fn attention_icon_name(&self) -> zbus::Result<String>;

    /// AttentionIconPixmap property
    #[zbus(property)]
    fn attention_icon_pixmap(&self) -> zbus::Result<Vec<IconPixmap>>;

    /// AttentionMovieName property
    #[zbus(property)]
    fn attention_movie_name(&self) -> zbus::Result<String>;

    /// Category property
    #[zbus(property)]
    fn category(&self) -> zbus::Result<String>;

    /// IconPixmap property
    #[zbus(property)]
    fn icon_pixmap(&self) -> zbus::Result<Vec<IconPixmap>>;

    /// IconThemePath property
    #[zbus(property)]
    fn icon_theme_path(&self) -> zbus::Result<String>;

    /// ItemIsMenu property
    #[zbus(property)]
    fn item_is_menu(&self) -> zbus::Result<bool>;

    /// OverlayIconName property
    #[zbus(property)]
    fn overlay_icon_name(&self) -> zbus::Result<String>;

    /// OverlayIconPixmap property
    #[zbus(property)]
    fn overlay_icon_pixmap(&self) -> zbus::Result<Vec<IconPixmap>>;

    /// ToolTip property
    #[zbus(property)]
    fn tool_tip(&self) -> zbus::Result<ToolTip>;

    /// WindowId property
    #[zbus(property)]
    fn window_id(&self) -> zbus::Result<i32>;
}
