//! # D-Bus interface proxy for: `org.kde.StatusNotifierItem`
//!
//! This code was generated by `zbus-xmlgen` `5.1.0` from D-Bus introspection data.
//! Source: `Interface '/StatusNotifierItem' from service ':1.9087' on system bus`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
//! following zbus API can be used:
//!
//! * [`zbus::fdo::PropertiesProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PeerProxy`]
//!
//! Consequently `zbus-xmlgen` did not generate code for the above interfaces.
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,
use zbus::{
    connection, interface,
    object_server::SignalEmitter,
    proxy,
    zvariant::{OwnedObjectPath, OwnedValue, Type, Value},
};

use crate::status_notifier_watcher::StatusNotifierWatcherProxy;

#[derive(Clone, PartialEq, Type, OwnedValue, Value)]
struct IconPixmap {
    width: i32,
    height: i32,
    data: Vec<u8>,
}

#[derive(Clone, PartialEq, Type, OwnedValue, Value)]
struct ToolTip {
    icon: String,
    data: Vec<IconPixmap>,
    title: String,
    description: String,
}

struct DBusMenu;

#[interface(name = "com.canonical.dbusmenu")]
impl DBusMenu {}

pub trait StatusNotifierItemProgram {
    type State;
    fn boot(&self) -> Self::State;
    fn id(&self) -> String;
    fn activate(&self, state: &Self::State, x: i32, y: i32) -> zbus::fdo::Result<()>;
    fn context_menu(&self, state: &Self::State, x: i32, y: i32) -> zbus::fdo::Result<()>;
    fn scroll(&self, state: &Self::State, delta: i32, orientation: &str) -> zbus::fdo::Result<()>;
    fn secondary_activate(&self, state: &Self::State, x: i32, y: i32) -> zbus::fdo::Result<()>;
    fn icon_name(&self, _state: &Self::State) -> zbus::fdo::Result<String> {
        Err(zbus::fdo::Error::NotSupported("Error".to_owned()))
    }
}

pub trait BootFn<State> {
    fn boot(&self) -> State;
}

impl<T, State> BootFn<State> for T
where
    T: Fn() -> State,
{
    fn boot(&self) -> State {
        self()
    }
}

pub trait IdFn {
    fn id(&self) -> String;
}

impl<T> IdFn for T
where
    T: Fn() -> String,
{
    fn id(&self) -> String {
        self()
    }
}

pub trait ActivateFn<State> {
    fn activate(&self, state: &State, x: i32, y: i32) -> zbus::fdo::Result<()>;
}

impl<T, State> ActivateFn<State> for T
where
    T: Fn(&State, i32, i32) -> zbus::fdo::Result<()>,
{
    fn activate(&self, state: &State, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self(state, x, y)
    }
}
pub trait ScrollFn<State> {
    fn scroll(&self, state: &State, delta: i32, orientation: &str) -> zbus::fdo::Result<()>;
}

impl<T, State> ScrollFn<State> for T
where
    T: Fn(&State, i32, &str) -> zbus::fdo::Result<()>,
{
    fn scroll(&self, state: &State, delta: i32, orientation: &str) -> zbus::fdo::Result<()> {
        self(state, delta, orientation)
    }
}
pub trait SecondaryActivateFn<State> {
    fn secondary_activate(&self, state: &State, x: i32, y: i32) -> zbus::fdo::Result<()>;
}

impl<T, State> SecondaryActivateFn<State> for T
where
    T: Fn(&State, i32, i32) -> zbus::fdo::Result<()>,
{
    fn secondary_activate(&self, state: &State, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self(state, x, y)
    }
}

pub trait ContextMenuFn<State> {
    fn context_menu(&self, state: &State, x: i32, y: i32) -> zbus::fdo::Result<()>;
}

impl<T, State> ContextMenuFn<State> for T
where
    T: Fn(&State, i32, i32) -> zbus::fdo::Result<()>,
{
    fn context_menu(&self, state: &State, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self(state, x, y)
    }
}

pub struct StatusNotifier<P: StatusNotifierItemProgram> {
    raw: P,
}

impl<P: StatusNotifierItemProgram> StatusNotifier<P>
where
    P::State: 'static + Send + Sync,
    P: Send + Sync + 'static,
{
    pub async fn run(self) -> zbus::Result<zbus::Connection> {
        let state = self.raw.boot();

        let instance = Instance {
            program: self.raw,
            state,
        };
        let conn = connection::Builder::session()?
            .serve_at("/StatusNotifierItem", instance)?
            .serve_at("/MenuBar", DBusMenu)?
            .build()
            .await?;
        let service = conn.unique_name().unwrap().to_string();
        StatusNotifierWatcherProxy::builder(&conn)
            .build()
            .await?
            .register_status_notifier_item(&service)
            .await?;
        Ok(conn)
    }

    pub fn with_icon_name(
        self,
        f: impl Fn(&P::State) -> zbus::fdo::Result<String>,
    ) -> StatusNotifier<impl StatusNotifierItemProgram<State = P::State>> {
        StatusNotifier {
            raw: with_icon_name(self.raw, f),
        }
    }
}

pub struct Instance<P: StatusNotifierItemProgram> {
    program: P,
    state: P::State,
}

#[interface(name = "org.kde.StatusNotifierItem")]
impl<P: StatusNotifierItemProgram> Instance<P>
where
    P: Send + Sync + 'static,
    P::State: 'static + Send + Sync,
{
    fn activate(&self, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self.program.activate(&self.state, x, y)
    }

    /// ContextMenu method
    fn context_menu(&self, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self.program.context_menu(&self.state, x, y)
    }

    fn scroll(&self, delta: i32, orientation: &str) -> zbus::fdo::Result<()> {
        self.program.scroll(&self.state, delta, orientation)
    }

    fn secondary_activate(&self, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self.program.secondary_activate(&self.state, x, y)
    }

    /// NewAttentionIcon signal
    #[zbus(signal)]
    async fn new_attention_icon(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewIcon signal
    #[zbus(signal)]
    async fn new_icon(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewMenu signal
    #[zbus(signal)]
    async fn new_menu(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewOverlayIcon signal
    #[zbus(signal)]
    async fn new_overlay_icon(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewStatus signal
    #[zbus(signal)]
    async fn new_status(ctxt: &SignalEmitter<'_>, status: &str) -> zbus::Result<()>;

    /// NewTitle signal
    #[zbus(signal)]
    async fn new_title(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewToolTip signal
    #[zbus(signal)]
    async fn new_tool_tip(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// Menu property
    #[zbus(property)]
    fn menu(&self) -> zbus::fdo::Result<zbus::zvariant::OwnedObjectPath> {
        Ok(OwnedObjectPath::try_from("/MenuBar").unwrap())
    }

    /// IconName property
    #[zbus(property)]
    fn icon_name(&self) -> zbus::fdo::Result<String> {
        self.program.icon_name(&self.state)
    }

    /// Id property
    #[zbus(property)]
    fn id(&self) -> zbus::fdo::Result<String> {
        Ok(self.program.id())
    }

    /// Status property
    #[zbus(property)]
    fn status(&self) -> zbus::fdo::Result<String> {
        Ok("Active".to_owned())
    }

    /// Title property
    #[zbus(property)]
    fn title(&self) -> zbus::fdo::Result<String> {
        Ok("test".to_owned())
    }
}

fn with_icon_name<P: StatusNotifierItemProgram>(
    program: P,
    icon: impl Fn(&P::State) -> zbus::fdo::Result<String>,
) -> impl StatusNotifierItemProgram<State = P::State>
where
    P::State: 'static + Send + Sync,
{
    struct WithTheme<P, F> {
        program: P,
        icon: F,
    }
    impl<P: StatusNotifierItemProgram, F> StatusNotifierItemProgram for WithTheme<P, F>
    where
        F: Fn(&P::State) -> zbus::fdo::Result<String>,
    {
        type State = P::State;

        fn id(&self) -> String {
            self.program.id()
        }
        fn boot(&self) -> Self::State {
            self.program.boot()
        }
        fn scroll(
            &self,
            state: &Self::State,
            delta: i32,
            orientation: &str,
        ) -> zbus::fdo::Result<()> {
            self.program.scroll(state, delta, orientation)
        }
        fn context_menu(&self, state: &Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.program.context_menu(state, x, y)
        }
        fn activate(&self, state: &Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.program.activate(state, x, y)
        }
        fn secondary_activate(&self, state: &Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.program.secondary_activate(state, x, y)
        }
        fn icon_name(&self, state: &Self::State) -> zbus::fdo::Result<String> {
            (self.icon)(state)
        }
    }
    WithTheme { program, icon }
}

pub fn application<State>(
    boot: impl BootFn<State>,
    id: impl IdFn,
    activate: impl ActivateFn<State>,
    context_menu: impl ContextMenuFn<State>,
    scroll: impl ScrollFn<State>,
    secondary_activate: impl SecondaryActivateFn<State>,
) -> StatusNotifier<impl StatusNotifierItemProgram<State = State>>
where
    State: 'static + Send + Sync,
{
    use std::marker::PhantomData;
    struct Instance<State, IdFn, BootFn, ActivateFn, ContextMenuFn, ScrollFn, SecondaryActivateFn> {
        boot: BootFn,
        id: IdFn,
        activate: ActivateFn,
        context_menu: ContextMenuFn,
        scroll: ScrollFn,
        secondary_activate: SecondaryActivateFn,
        _state: PhantomData<State>,
    }
    impl<State, IdFn, BootFn, ActivateFn, ContextMenuFn, ScrollFn, SecondaryActivateFn>
        StatusNotifierItemProgram
        for Instance<State, IdFn, BootFn, ActivateFn, ContextMenuFn, ScrollFn, SecondaryActivateFn>
    where
        BootFn: self::BootFn<State>,
        IdFn: self::IdFn,
        ActivateFn: self::ActivateFn<State>,
        ContextMenuFn: self::ContextMenuFn<State>,
        ScrollFn: self::ScrollFn<State>,
        SecondaryActivateFn: self::SecondaryActivateFn<State>,
    {
        type State = State;
        fn id(&self) -> String {
            self.id.id()
        }
        fn boot(&self) -> Self::State {
            self.boot.boot()
        }
        fn scroll(
            &self,
            state: &Self::State,
            delta: i32,
            orientation: &str,
        ) -> zbus::fdo::Result<()> {
            self.scroll.scroll(state, delta, orientation)
        }
        fn context_menu(&self, state: &Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.context_menu.context_menu(state, x, y)
        }
        fn activate(&self, state: &Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.activate.activate(state, x, y)
        }
        fn secondary_activate(&self, state: &Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
            self.secondary_activate.secondary_activate(state, x, y)
        }
    }

    StatusNotifier {
        raw: Instance {
            boot,
            id,
            activate,
            context_menu,
            scroll,
            secondary_activate,
            _state: PhantomData,
        },
    }
}

#[proxy(
    interface = "org.kde.StatusNotifierItem",
    default_path = "/StatusNotifierItem"
)]
pub trait StatusNotifierItem {
    /// AttentionIconName property
    #[zbus(property)]
    fn attention_icon_name(&self) -> zbus::Result<String>;

    /// AttentionIconPixmap property
    #[zbus(property)]
    fn attention_icon_pixmap(&self) -> zbus::Result<Vec<IconPixmap>>;

    /// AttentionMovieName property
    #[zbus(property)]
    fn attention_movie_name(&self) -> zbus::Result<String>;

    /// Category property
    #[zbus(property)]
    fn category(&self) -> zbus::Result<String>;

    /// IconPixmap property
    #[zbus(property)]
    fn icon_pixmap(&self) -> zbus::Result<Vec<IconPixmap>>;

    /// IconThemePath property
    #[zbus(property)]
    fn icon_theme_path(&self) -> zbus::Result<String>;

    /// ItemIsMenu property
    #[zbus(property)]
    fn item_is_menu(&self) -> zbus::Result<bool>;

    /// OverlayIconName property
    #[zbus(property)]
    fn overlay_icon_name(&self) -> zbus::Result<String>;

    /// OverlayIconPixmap property
    #[zbus(property)]
    fn overlay_icon_pixmap(&self) -> zbus::Result<Vec<IconPixmap>>;

    /// ToolTip property
    #[zbus(property)]
    fn tool_tip(&self) -> zbus::Result<ToolTip>;

    /// WindowId property
    #[zbus(property)]
    fn window_id(&self) -> zbus::Result<i32>;
}
