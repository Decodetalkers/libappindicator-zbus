//! # D-Bus interface proxy for: `org.kde.StatusNotifierItem`
//!
//! This code was generated by `zbus-xmlgen` `5.1.0` from D-Bus introspection data.
//! Source: `Interface '/StatusNotifierItem' from service ':1.9087' on system bus`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
//! following zbus API can be used:
//!
//! * [`zbus::fdo::PropertiesProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PeerProxy`]
//!
//! Consequently `zbus-xmlgen` did not generate code for the above interfaces.
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,

use serde::{Deserialize, Serialize};
use zbus::{
    interface,
    object_server::SignalEmitter,
    proxy,
    zvariant::{OwnedObjectPath, OwnedValue, Type, Value},
};

#[derive(Clone, PartialEq, Type, OwnedValue, Value, Debug, Default)]
pub struct IconPixmap {
    pub width: i32,
    pub height: i32,
    pub data: Vec<u8>,
}

#[derive(Clone, PartialEq, Type, OwnedValue, Value, Default, Debug)]
struct ToolTip {
    icon: String,
    data: Vec<IconPixmap>,
    title: String,
    description: String,
}

#[derive(Clone, PartialEq, Type, OwnedValue, Value, Debug, Default, Serialize, Deserialize)]
#[zvariant(signature = "s")]
pub enum NotifierStatus {
    #[default]
    Active,
    Passive,
    NeedsAttention,
}

pub trait StatusNotifierItem {
    type State;
    fn boot(&self) -> Self::State;
    fn id(&self) -> String;
    #[allow(unused)]
    fn activate(&self, state: &mut Self::State, x: i32, y: i32) -> zbus::fdo::Result<()> {
        Ok(())
    }
    fn context_menu(&self, _state: &mut Self::State, _x: i32, _y: i32) -> zbus::fdo::Result<()> {
        Err(zbus::fdo::Error::NotSupported("Error".to_owned()))
    }
    fn scroll(
        &self,
        _state: &mut Self::State,
        _delta: i32,
        _orientation: &str,
    ) -> zbus::fdo::Result<()> {
        Err(zbus::fdo::Error::NotSupported("Error".to_owned()))
    }
    fn secondary_activate(
        &self,
        _state: &mut Self::State,
        _x: i32,
        _y: i32,
    ) -> zbus::fdo::Result<()> {
        Err(zbus::fdo::Error::NotSupported("Error".to_owned()))
    }

    #[allow(unused)]
    fn icon_name(&self, state: &Self::State) -> zbus::fdo::Result<String> {
        Err(zbus::fdo::Error::NotSupported("Unimplemented".to_string()))
    }

    #[allow(unused)]
    fn icon_pixmap(&self, state: &Self::State) -> zbus::fdo::Result<Vec<IconPixmap>> {
        Err(zbus::fdo::Error::NotSupported("Unimplemented".to_string()))
    }

    #[allow(unused)]
    fn attention_icon_pixmap(&self, state: &Self::State) -> zbus::fdo::Result<Vec<IconPixmap>> {
        Err(zbus::fdo::Error::NotSupported("Unimplemented".to_string()))
    }

    #[allow(unused)]
    fn overlay_icon_name(&self, state: &Self::State) -> zbus::fdo::Result<String> {
        Err(zbus::fdo::Error::NotSupported("Unimplemented".to_string()))
    }

    #[allow(unused)]
    fn overlay_icon_pixmap(&self, state: &Self::State) -> zbus::fdo::Result<Vec<IconPixmap>> {
        Err(zbus::fdo::Error::NotSupported("Unimplemented".to_string()))
    }

    #[allow(unused)]
    fn attention_icon_name(&self, state: &Self::State) -> zbus::fdo::Result<String> {
        Ok("".to_string())
    }

    fn category(&self) -> zbus::fdo::Result<String> {
        Ok("SystemService".to_string())
    }

    fn title(&self, state: &Self::State) -> zbus::fdo::Result<String>;

    #[allow(unused)]
    fn status(&self, state: &Self::State) -> zbus::fdo::Result<NotifierStatus> {
        Ok(NotifierStatus::Active)
    }

    #[allow(unused)]
    fn item_is_menu(&self, state: &Self::State) -> bool {
        false
    }
}

pub trait NotifierBootFn<State> {
    fn boot(&self) -> State;
}

impl<T, State> NotifierBootFn<State> for T
where
    T: Fn() -> State,
{
    fn boot(&self) -> State {
        self()
    }
}

pub trait IdFn {
    fn id(&self) -> String;
}

impl<T> IdFn for T
where
    T: Fn() -> String,
{
    fn id(&self) -> String {
        self()
    }
}

impl IdFn for &str {
    fn id(&self) -> String {
        self.to_string()
    }
}

impl IdFn for String {
    fn id(&self) -> String {
        self.clone()
    }
}

pub trait CategoryFn {
    fn category(&self) -> String;
}

impl<T> CategoryFn for T
where
    T: Fn() -> String,
{
    fn category(&self) -> String {
        self()
    }
}

impl CategoryFn for &str {
    fn category(&self) -> String {
        self.to_string()
    }
}

impl CategoryFn for String {
    fn category(&self) -> String {
        self.clone()
    }
}

pub trait ActivateFn<State> {
    fn activate(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()>;
}

impl<T, State> ActivateFn<State> for T
where
    T: Fn(&mut State, i32, i32) -> zbus::fdo::Result<()>,
{
    fn activate(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self(state, x, y)
    }
}
pub trait ScrollFn<State> {
    fn scroll(&self, state: &mut State, delta: i32, orientation: &str) -> zbus::fdo::Result<()>;
}

impl<T, State> ScrollFn<State> for T
where
    T: Fn(&mut State, i32, &str) -> zbus::fdo::Result<()>,
{
    fn scroll(&self, state: &mut State, delta: i32, orientation: &str) -> zbus::fdo::Result<()> {
        self(state, delta, orientation)
    }
}
pub trait SecondaryActivateFn<State> {
    fn secondary_activate(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()>;
}

impl<T, State> SecondaryActivateFn<State> for T
where
    T: Fn(&mut State, i32, i32) -> zbus::fdo::Result<()>,
{
    fn secondary_activate(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self(state, x, y)
    }
}

pub trait ContextMenuFn<State> {
    fn context_menu(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()>;
}

impl<T, State> ContextMenuFn<State> for T
where
    T: Fn(&mut State, i32, i32) -> zbus::fdo::Result<()>,
{
    fn context_menu(&self, state: &mut State, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self(state, x, y)
    }
}

pub trait TitleFn<State> {
    fn title(&self, state: &State) -> zbus::fdo::Result<String>;
}

impl<State> TitleFn<State> for &str {
    fn title(&self, _state: &State) -> zbus::fdo::Result<String> {
        Ok(self.to_string())
    }
}

impl<State> TitleFn<State> for String {
    fn title(&self, _state: &State) -> zbus::fdo::Result<String> {
        Ok(self.clone())
    }
}

impl<State, T> TitleFn<State> for T
where
    T: Fn(&State) -> zbus::fdo::Result<String>,
{
    fn title(&self, state: &State) -> zbus::fdo::Result<String> {
        self(state)
    }
}

pub trait IconNameFn<State> {
    fn icon_name(&self, state: &State) -> zbus::fdo::Result<String>;
}

impl<State> IconNameFn<State> for &str {
    fn icon_name(&self, _state: &State) -> zbus::fdo::Result<String> {
        Ok(self.to_string())
    }
}

impl<State> IconNameFn<State> for String {
    fn icon_name(&self, _state: &State) -> zbus::fdo::Result<String> {
        Ok(self.clone())
    }
}

impl<State, T> IconNameFn<State> for T
where
    T: Fn(&State) -> zbus::fdo::Result<String>,
{
    fn icon_name(&self, state: &State) -> zbus::fdo::Result<String> {
        self(state)
    }
}

pub trait IconPixmapFn<State> {
    fn icon_pixmap(&self, state: &State) -> zbus::fdo::Result<Vec<IconPixmap>>;
}

impl<State, T> IconPixmapFn<State> for T
where
    T: Fn(&State) -> zbus::fdo::Result<Vec<IconPixmap>>,
{
    fn icon_pixmap(&self, state: &State) -> zbus::fdo::Result<Vec<IconPixmap>> {
        self(state)
    }
}

pub trait AttentionIconNameFn<State> {
    fn icon_name(&self, state: &State) -> zbus::fdo::Result<String>;
}

impl<State> AttentionIconNameFn<State> for &str {
    fn icon_name(&self, _state: &State) -> zbus::fdo::Result<String> {
        Ok(self.to_string())
    }
}

impl<State> AttentionIconNameFn<State> for String {
    fn icon_name(&self, _state: &State) -> zbus::fdo::Result<String> {
        Ok(self.clone())
    }
}

impl<State, T> AttentionIconNameFn<State> for T
where
    T: Fn(&State) -> zbus::fdo::Result<String>,
{
    fn icon_name(&self, state: &State) -> zbus::fdo::Result<String> {
        self(state)
    }
}

pub trait AttentionIconPixmapFn<State> {
    fn attention_icon_pixmap(&self, state: &State) -> zbus::fdo::Result<Vec<IconPixmap>>;
}

impl<State, T> AttentionIconPixmapFn<State> for T
where
    T: Fn(&State) -> zbus::fdo::Result<Vec<IconPixmap>>,
{
    fn attention_icon_pixmap(&self, state: &State) -> zbus::fdo::Result<Vec<IconPixmap>> {
        self(state)
    }
}
pub trait OverlayIconNameFn<State> {
    fn overlay_icon_name(&self, state: &State) -> zbus::fdo::Result<String>;
}

impl<State> OverlayIconNameFn<State> for &str {
    fn overlay_icon_name(&self, _state: &State) -> zbus::fdo::Result<String> {
        Ok(self.to_string())
    }
}

impl<State> OverlayIconNameFn<State> for String {
    fn overlay_icon_name(&self, _state: &State) -> zbus::fdo::Result<String> {
        Ok(self.clone())
    }
}

impl<State, T> OverlayIconNameFn<State> for T
where
    T: Fn(&State) -> zbus::fdo::Result<String>,
{
    fn overlay_icon_name(&self, state: &State) -> zbus::fdo::Result<String> {
        self(state)
    }
}

pub trait OverlayIconPixmapFn<State> {
    fn overlay_icon_pixmap(&self, state: &State) -> zbus::fdo::Result<Vec<IconPixmap>>;
}

impl<State, T> OverlayIconPixmapFn<State> for T
where
    T: Fn(&State) -> zbus::fdo::Result<Vec<IconPixmap>>,
{
    fn overlay_icon_pixmap(&self, state: &State) -> zbus::fdo::Result<Vec<IconPixmap>> {
        self(state)
    }
}

pub trait NotifierStatusFn<State> {
    fn status(&self, state: &State) -> NotifierStatus;
}

impl<State, T> NotifierStatusFn<State> for T
where
    T: Fn(&State) -> NotifierStatus,
{
    fn status(&self, state: &State) -> NotifierStatus {
        self(state)
    }
}
pub trait ItemIsMenuFn<State> {
    fn item_is_menu(&self, state: &State) -> bool;
}

impl<State, T> ItemIsMenuFn<State> for T
where
    T: Fn(&State) -> bool,
{
    fn item_is_menu(&self, state: &State) -> bool {
        self(state)
    }
}

impl<State> ItemIsMenuFn<State> for bool {
    fn item_is_menu(&self, _state: &State) -> bool {
        self.clone()
    }
}

pub struct StatusNotifierInstance<P: StatusNotifierItem> {
    pub(crate) program: P,
    pub(crate) state: P::State,
}

#[interface(name = "org.kde.StatusNotifierItem")]
impl<P: StatusNotifierItem> StatusNotifierInstance<P>
where
    P: Send + Sync + 'static,
    P::State: 'static + Send + Sync,
{
    fn activate(&mut self, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self.program.activate(&mut self.state, x, y)
    }

    /// ContextMenu method
    fn context_menu(&mut self, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self.program.context_menu(&mut self.state, x, y)
    }

    fn scroll(&mut self, delta: i32, orientation: &str) -> zbus::fdo::Result<()> {
        self.program.scroll(&mut self.state, delta, orientation)
    }

    fn secondary_activate(&mut self, x: i32, y: i32) -> zbus::fdo::Result<()> {
        self.program.secondary_activate(&mut self.state, x, y)
    }

    /// NewAttentionIcon signal
    #[zbus(signal)]
    async fn new_attention_icon(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewIcon signal
    #[zbus(signal)]
    pub async fn new_icon(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewMenu signal
    #[zbus(signal)]
    pub async fn new_menu(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewOverlayIcon signal
    #[zbus(signal)]
    pub async fn new_overlay_icon(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewStatus signal
    #[zbus(signal)]
    pub async fn new_status(ctxt: &SignalEmitter<'_>, status: &str) -> zbus::Result<()>;

    /// NewTitle signal
    #[zbus(signal)]
    pub async fn new_title(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// NewToolTip signal
    #[zbus(signal)]
    pub async fn new_tool_tip(ctxt: &SignalEmitter<'_>) -> zbus::Result<()>;

    /// Menu property
    #[zbus(property)]
    fn menu(&self) -> zbus::fdo::Result<zbus::zvariant::OwnedObjectPath> {
        Ok(OwnedObjectPath::try_from("/MenuBar").unwrap())
    }

    /// IconName property
    #[zbus(property)]
    fn icon_name(&self) -> zbus::fdo::Result<String> {
        self.program.icon_name(&self.state)
    }

    /// IconPixmap property
    #[zbus(property)]
    fn icon_pixmap(&self) -> zbus::fdo::Result<Vec<IconPixmap>> {
        self.program.icon_pixmap(&self.state)
    }

    /// AttentionIconName property
    #[zbus(property)]
    fn attention_icon_name(&self) -> zbus::fdo::Result<String> {
        self.program.attention_icon_name(&self.state)
    }
    /// AttentionIconPixmap property
    #[zbus(property)]
    fn attention_icon_pixmap(&self) -> zbus::fdo::Result<Vec<IconPixmap>> {
        self.program.attention_icon_pixmap(&self.state)
    }

    /// OverlayIconName property
    #[zbus(property)]
    fn overlay_icon_name(&self) -> zbus::fdo::Result<String> {
        self.program.overlay_icon_name(&self.state)
    }

    /// OverlayIconPixmap property
    #[zbus(property)]
    fn overlay_icon_pixmap(&self) -> zbus::fdo::Result<Vec<IconPixmap>> {
        self.program.overlay_icon_pixmap(&self.state)
    }

    /// Category property
    #[zbus(property)]
    fn category(&self) -> zbus::fdo::Result<String> {
        self.program.category()
    }
    /// Id property
    #[zbus(property)]
    fn id(&self) -> zbus::fdo::Result<String> {
        Ok(self.program.id())
    }

    /// Status property
    #[zbus(property)]
    fn status(&self) -> zbus::fdo::Result<NotifierStatus> {
        self.program.status(&self.state)
    }

    /// Title property
    #[zbus(property)]
    fn title(&self) -> zbus::fdo::Result<String> {
        self.program.title(&self.state)
    }

    /// ItemIsMenu property
    #[zbus(property)]
    fn item_is_menu(&self) -> zbus::fdo::Result<bool> {
        Ok(self.program.item_is_menu(&self.state))
    }
}

#[proxy(
    interface = "org.kde.StatusNotifierItem",
    default_path = "/StatusNotifierItem"
)]
pub trait StatusNotifierItemBackend {
    /// AttentionMovieName property
    #[zbus(property)]
    fn attention_movie_name(&self) -> zbus::Result<String>;

    /// IconThemePath property
    #[zbus(property)]
    fn icon_theme_path(&self) -> zbus::Result<String>;

    /// ToolTip property
    #[zbus(property)]
    fn tool_tip(&self) -> zbus::Result<ToolTip>;

    /// WindowId property
    #[zbus(property)]
    fn window_id(&self) -> zbus::Result<i32>;
}
