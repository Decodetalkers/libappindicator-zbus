//! # D-Bus interface proxy for: `com.canonical.dbusmenu`
//!
//! This code was generated by `zbus-xmlgen` `5.1.0` from D-Bus introspection data.
//! Source: `Interface '/MenuBar' from service ':1.9087' on system bus`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
//! following zbus API can be used:
//!
//! * [`zbus::fdo::PropertiesProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PeerProxy`]
//!
//! Consequently `zbus-xmlgen` did not generate code for the above interfaces.
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,
use serde::{Deserialize, Serialize};
use zbus::zvariant::{self, OwnedValue, Type, Value, as_value::optional};

use zbus::{interface, object_server::SignalEmitter};

pub mod event_types;

pub use event_types::*;

#[derive(Type, Debug, Serialize, Deserialize, Default, OwnedValue, Value, Clone)]
/// Specified options for a [`Screencast::create_session`] request.
#[zvariant(signature = "dict")]
pub struct MenuProperty {
    #[serde(with = "optional", skip_serializing_if = "Option::is_none", default)]
    pub label: Option<String>,
    #[serde(with = "optional", skip_serializing_if = "Option::is_none", default)]
    #[zvariant(rename = "icon-name")]
    pub icon_name: Option<String>,
    #[serde(with = "optional", skip_serializing_if = "Option::is_none", default)]
    pub enabled: Option<bool>,
    #[serde(with = "optional", skip_serializing_if = "Option::is_none", default)]
    #[zvariant(rename = "toggle-type")]
    pub toggle_type: Option<ToggleType>,
    #[serde(with = "optional", skip_serializing_if = "Option::is_none", default)]
    #[zvariant(rename = "toggle-state")]
    pub toggle_state: Option<ToggleState>,
    #[serde(with = "optional", skip_serializing_if = "Option::is_none", default)]
    #[zvariant(rename = "children-display")]
    pub children_display: Option<String>,
}

impl MenuProperty {
    /// Key name
    pub const LABEL: &str = "label";
    pub const ICON_NAME: &str = "icon-name";
    pub const ENABLED: &str = "enabled";
    pub const TOGGLE_TYPE: &str = "toggle-type";
    pub const TOGGLE_STATE: &str = "toggle-state";
    pub const CHILDREN_DISPLAY: &str = "children-display";
}

impl MenuProperty {
    pub fn submenu() -> Self {
        MenuProperty {
            label: Some("root".to_owned()),
            children_display: Some("submenu".to_owned()),
            ..Default::default()
        }
    }
}

#[derive(Type, Debug, Serialize, Deserialize, OwnedValue, Value, Clone)]
#[zvariant(signature = "(ia{sv}av)")]
pub struct MenuItem {
    pub id: i32,
    pub property: MenuProperty,
    pub sub_menus: Vec<zvariant::OwnedValue>,
}

#[derive(Clone, PartialEq, Type, Serialize, Deserialize, OwnedValue, Value, Debug, Default)]
#[zvariant(signature = "s", rename_all = "lowercase")]
pub enum MenuStatus {
    #[default]
    Normal,
    Notice,
    Disabled,
}

impl Default for MenuItem {
    fn default() -> Self {
        MenuItem {
            id: 1,
            property: MenuProperty::submenu(),
            sub_menus: vec![],
        }
    }
}

impl MenuItem {
    pub fn new(id: i32, property: MenuProperty) -> Self {
        MenuItem {
            id,
            property,
            sub_menus: vec![],
        }
    }
    pub fn push_sub_menu(mut self, menu: MenuItem) -> Self {
        self.sub_menus.push(OwnedValue::try_from(menu).unwrap());
        self
    }

    pub fn get_property(&self, id: i32) -> Option<PropertyItem> {
        if self.id == id {
            return Some(PropertyItem {
                id,
                item: self.property.clone(),
            });
        }
        let sub_menus: Vec<MenuItem> = self
            .sub_menus
            .iter()
            .map(|submenu| submenu.clone().try_into().unwrap())
            .collect();

        for sub_menu in sub_menus {
            let property = sub_menu.get_property(id);
            if property.is_some() {
                return property;
            }
        }

        None
    }

    pub fn get_property_groups(&self, ids: Vec<i32>) -> Vec<PropertyItem> {
        let mut output = vec![];
        for id in ids {
            if let Some(property) = self.get_property(id) {
                output.push(property);
            }
        }

        output
    }
}

#[derive(Type, Debug, Default, Serialize, Deserialize)]
pub struct LayoutData {
    pub revision: u32,
    pub data: MenuItem,
}

#[derive(Type, Debug, Default, Serialize, Deserialize)]
pub struct PropertyItem {
    pub id: i32,
    pub item: MenuProperty,
}

pub trait DBusMenuItem {
    type State;

    fn boot(&self) -> Self::State;

    fn about_to_show(&self, state: &mut Self::State, id: i32) -> zbus::fdo::Result<bool>;

    /// AboutToShowGroup method
    #[allow(unused)]
    fn about_to_show_group(
        &self,
        state: &mut Self::State,
        ids: Vec<i32>,
    ) -> zbus::fdo::Result<(Vec<i32>, Vec<i32>)> {
        Err(zbus::fdo::Error::Failed("Unimplemented".to_string()))
    }

    #[allow(unused)]
    fn get_layout(
        &self,
        state: &mut Self::State,
        parent_id: i32,
        recursion_depth: i32,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<(u32, MenuItem)> {
        Ok((1, MenuItem::default()))
    }

    fn status(&self, _state: &Self::State) -> zbus::fdo::Result<MenuStatus> {
        Ok(MenuStatus::Normal)
    }

    #[allow(unused)]
    fn get_group_properties(
        &self,
        state: &mut Self::State,
        ids: Vec<i32>,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<Vec<PropertyItem>> {
        Ok(vec![])
    }

    #[allow(unused)]
    fn get_property(
        &self,
        state: &mut Self::State,
        id: i32,
        name: String,
    ) -> zbus::fdo::Result<PropertyItem> {
        Err(zbus::fdo::Error::Failed("Unimplemented".to_string()))
    }

    #[allow(unused)]
    fn on_clicked(&self, state: &mut Self::State, id: i32, timestamp: u32) -> EventUpdate {
        EventUpdate::None
    }

    #[allow(unused)]
    fn on_toggled(
        &self,
        state: &mut Self::State,
        id: i32,
        status: ToggleState,
        timestamp: u32,
    ) -> EventUpdate {
        EventUpdate::None
    }

    #[allow(unused)]
    fn text_direction(&self, state: &Self::State) -> TextDirection {
        TextDirection::Inherit
    }

    #[allow(unused)]
    fn icon_theme_path(&self, state: &Self::State) -> Vec<String> {
        vec![]
    }
}

pub struct DBusMenuInstance<Menu: DBusMenuItem> {
    pub(crate) program: Menu,
    pub(crate) state: Menu::State,
}

pub trait DBusMenuBootFn<State> {
    fn boot(&self) -> State;
}

impl<T, State> DBusMenuBootFn<State> for T
where
    T: Fn() -> State,
{
    fn boot(&self) -> State {
        self()
    }
}

pub trait MenuStatusFn<State> {
    fn status(&self, state: &State) -> MenuStatus;
}

impl<T, State> MenuStatusFn<State> for T
where
    T: Fn(&State) -> MenuStatus,
{
    fn status(&self, state: &State) -> MenuStatus {
        self(state)
    }
}
pub trait AboutToShowFn<State> {
    fn about_to_show(&self, state: &mut State, id: i32) -> zbus::fdo::Result<bool>;
}

impl<T, State> AboutToShowFn<State> for T
where
    T: Fn(&mut State, i32) -> zbus::fdo::Result<bool>,
{
    fn about_to_show(&self, state: &mut State, id: i32) -> zbus::fdo::Result<bool> {
        self(state, id)
    }
}

pub trait GetLayoutFn<State> {
    fn get_layout(
        &self,
        state: &mut State,
        parent_id: i32,
        recursion_depth: i32,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<(u32, MenuItem)>;
}

impl<T, State> GetLayoutFn<State> for T
where
    T: Fn(&mut State, i32, i32, Vec<String>) -> zbus::fdo::Result<(u32, MenuItem)>,
{
    fn get_layout(
        &self,
        state: &mut State,
        parent_id: i32,
        recursion_depth: i32,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<(u32, MenuItem)> {
        self(state, parent_id, recursion_depth, property_names)
    }
}

pub trait GetGroupPropertiesFn<State> {
    fn get_group_properties(
        &self,
        state: &mut State,
        ids: Vec<i32>,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<Vec<PropertyItem>>;
}

impl<T, State> GetGroupPropertiesFn<State> for T
where
    T: Fn(&mut State, Vec<i32>, Vec<String>) -> zbus::fdo::Result<Vec<PropertyItem>>,
{
    fn get_group_properties(
        &self,
        state: &mut State,
        ids: Vec<i32>,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<Vec<PropertyItem>> {
        self(state, ids, property_names)
    }
}
pub trait GetPropertyFn<State> {
    fn get_property(
        &self,
        state: &mut State,
        id: i32,
        property_name: String,
    ) -> zbus::fdo::Result<PropertyItem>;
}

impl<T, State> GetPropertyFn<State> for T
where
    T: Fn(&mut State, i32, String) -> zbus::fdo::Result<PropertyItem>,
{
    fn get_property(
        &self,
        state: &mut State,
        id: i32,
        property_name: String,
    ) -> zbus::fdo::Result<PropertyItem> {
        self(state, id, property_name)
    }
}

#[derive(Debug)]
pub enum EventUpdate {
    None,
    Update { revision: u32, parent: i32 },
}

pub trait OnClickedFn<State> {
    fn on_clicked(&self, state: &mut State, id: i32, timestamp: u32) -> EventUpdate;
}

impl<T, State> OnClickedFn<State> for T
where
    T: Fn(&mut State, i32, u32) -> EventUpdate,
{
    fn on_clicked(&self, state: &mut State, id: i32, timestamp: u32) -> EventUpdate {
        self(state, id, timestamp)
    }
}

pub trait OnToggledFn<State> {
    fn on_toggled(
        &self,
        state: &mut State,
        id: i32,
        status: ToggleState,
        timestamp: u32,
    ) -> EventUpdate;
}

impl<T, State> OnToggledFn<State> for T
where
    T: Fn(&mut State, i32, ToggleState, u32) -> EventUpdate,
{
    fn on_toggled(
        &self,
        state: &mut State,
        id: i32,
        status: ToggleState,
        timestamp: u32,
    ) -> EventUpdate {
        self(state, id, status, timestamp)
    }
}

pub trait TextDirectionFn<State> {
    fn text_direction(&self, state: &State) -> TextDirection;
}

impl<State> TextDirectionFn<State> for TextDirection {
    fn text_direction(&self, _state: &State) -> TextDirection {
        *self
    }
}

impl<T, State> TextDirectionFn<State> for T
where
    T: Fn(&State) -> TextDirection,
{
    fn text_direction(&self, state: &State) -> TextDirection {
        self(state)
    }
}

pub trait IconThemePathFn<State> {
    fn icon_theme_path(&self, state: &State) -> Vec<String>;
}

impl<State> IconThemePathFn<State> for Vec<String> {
    fn icon_theme_path(&self, _state: &State) -> Vec<String> {
        self.clone()
    }
}

impl<T, State> IconThemePathFn<State> for T
where
    T: Fn(&State) -> Vec<String>,
{
    fn icon_theme_path(&self, state: &State) -> Vec<String> {
        self(state)
    }
}

pub trait AboutToShowGroupFn<State> {
    fn about_to_show_group(
        &self,
        state: &mut State,
        ids: Vec<i32>,
    ) -> zbus::fdo::Result<(Vec<i32>, Vec<i32>)>;
}

impl<T, State> AboutToShowGroupFn<State> for T
where
    T: Fn(&mut State, Vec<i32>) -> zbus::fdo::Result<(Vec<i32>, Vec<i32>)>,
{
    fn about_to_show_group(
        &self,
        state: &mut State,
        ids: Vec<i32>,
    ) -> zbus::fdo::Result<(Vec<i32>, Vec<i32>)> {
        self(state, ids)
    }
}

#[interface(name = "com.canonical.dbusmenu")]
impl<Menu: DBusMenuItem> DBusMenuInstance<Menu>
where
    Menu: Send + Sync + 'static,
    Menu::State: 'static + Send + Sync,
{
    fn about_to_show(&mut self, id: i32) -> zbus::fdo::Result<bool> {
        self.program.about_to_show(&mut self.state, id)
    }

    /// AboutToShowGroup method
    fn about_to_show_group(&mut self, ids: Vec<i32>) -> zbus::fdo::Result<(Vec<i32>, Vec<i32>)> {
        self.program.about_to_show_group(&mut self.state, ids)
    }

    // NOTE: this should not implemented by user
    /// GetLayout method
    fn get_layout(
        &mut self,
        parent_id: i32,
        recursion_depth: i32,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<(u32, MenuItem)> {
        self.program
            .get_layout(&mut self.state, parent_id, recursion_depth, property_names)
    }

    // NOTE: this should not implemented by user
    /// GetGroupProperties method
    fn get_group_properties(
        &mut self,
        ids: Vec<i32>,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<Vec<PropertyItem>> {
        self.program
            .get_group_properties(&mut self.state, ids, property_names)
    }

    // NOTE: this should not implemented by user
    /// GetProperty method
    fn get_property(&mut self, id: i32, name: String) -> zbus::fdo::Result<PropertyItem> {
        self.program.get_property(&mut self.state, id, name)
    }

    /// Version property
    #[zbus(property)]
    fn version(&self) -> u32 {
        2
    }

    /// Status property
    #[zbus(property)]
    fn status(&self) -> zbus::fdo::Result<MenuStatus> {
        self.program.status(&self.state)
    }

    /// Event method
    async fn event(
        &mut self,
        id: i32,
        event_id: String,
        data: zbus::zvariant::OwnedValue,
        timestamp: u32,
        #[zbus(object_server)] server: &zbus::ObjectServer,
    ) -> zbus::fdo::Result<()> {
        let need_update = match event_id.as_str() {
            "clicked" => self.program.on_clicked(&mut self.state, id, timestamp),
            "toggled" => {
                let status: ToggleState = data
                    .try_into()
                    .map_err(|e| zbus::fdo::Error::Failed(format!("data error: {e}")))?;
                self.program
                    .on_toggled(&mut self.state, id, status, timestamp)
            }
            _ => EventUpdate::None,
        };
        if let EventUpdate::Update { revision, parent } = need_update {
            let iface_rf = server
                .interface::<_, DBusMenuInstance<Menu>>("/MenuBar")
                .await?;
            let _ = DBusMenuInstance::<Menu>::layout_updated(
                iface_rf.signal_emitter(),
                revision,
                parent,
            )
            .await;
        }
        Ok(())
    }

    /// EventGroup method
    async fn event_group(
        &mut self,
        events: Vec<(i32, String, zbus::zvariant::OwnedValue, u32)>,
        #[zbus(object_server)] server: &zbus::ObjectServer,
    ) -> zbus::fdo::Result<Vec<i32>> {
        let mut output = vec![];
        for (id, event_id, data, timestamp) in events {
            let need_update = match event_id.as_str() {
                "clicked" => self.program.on_clicked(&mut self.state, id, timestamp),
                "toggled" => {
                    let status: ToggleState = data
                        .try_into()
                        .map_err(|e| zbus::fdo::Error::Failed(format!("data error: {e}")))?;
                    self.program
                        .on_toggled(&mut self.state, id, status, timestamp)
                }
                _ => {
                    continue;
                }
            };
            if let EventUpdate::Update { revision, parent } = need_update {
                let iface_rf = server
                    .interface::<_, DBusMenuInstance<Menu>>("/MenuBar")
                    .await?;
                let _ = DBusMenuInstance::<Menu>::layout_updated(
                    iface_rf.signal_emitter(),
                    revision,
                    parent,
                )
                .await;
            }
            output.push(id);
        }
        Ok(output)
    }

    /// TextDirection property
    #[zbus(property)]
    fn text_direction(&self) -> TextDirection {
        self.program.text_direction(&self.state)
    }

    #[zbus(property)]
    fn icon_theme_path(&self) -> Vec<String> {
        self.program.icon_theme_path(&self.state)
    }

    /// ItemActivationRequested signal
    #[zbus(signal)]
    pub async fn item_activation_requested(
        ctxt: &SignalEmitter<'_>,
        id: i32,
        timestamp: u32,
    ) -> zbus::Result<()>;

    /// ItemsPropertiesUpdated signal
    #[zbus(signal)]
    pub async fn items_properties_updated(
        ctxt: &SignalEmitter<'_>,
        updated_props: Vec<(i32, MenuProperty)>,
        removed_props: Vec<(i32, Vec<&str>)>,
    ) -> zbus::Result<()>;

    /// LayoutUpdated signal
    #[zbus(signal)]
    pub async fn layout_updated(
        ctxt: &SignalEmitter<'_>,
        revision: u32,
        parent: i32,
    ) -> zbus::Result<()>;
}
