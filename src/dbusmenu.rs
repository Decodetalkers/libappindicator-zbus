//! # D-Bus interface proxy for: `com.canonical.dbusmenu`
//!
//! This code was generated by `zbus-xmlgen` `5.1.0` from D-Bus introspection data.
//! Source: `Interface '/MenuBar' from service ':1.9087' on system bus`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
//! following zbus API can be used:
//!
//! * [`zbus::fdo::PropertiesProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PeerProxy`]
//!
//! Consequently `zbus-xmlgen` did not generate code for the above interfaces.
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,
use serde::{Deserialize, Serialize};
use zbus::zvariant::{self, OwnedValue, Type, Value, as_value::optional};

use zbus::{interface, object_server::SignalEmitter, proxy};

pub mod event_types;

pub use event_types::*;

#[derive(Type, Debug, Serialize, Deserialize, Default, OwnedValue, Value)]
/// Specified options for a [`Screencast::create_session`] request.
#[zvariant(signature = "dict")]
pub struct MenuProperty {
    #[serde(with = "optional", skip_serializing_if = "Option::is_none", default)]
    pub label: Option<String>,
    #[serde(with = "optional", skip_serializing_if = "Option::is_none", default)]
    pub icon_name: Option<String>,
    #[serde(with = "optional", skip_serializing_if = "Option::is_none", default)]
    pub enabled: Option<bool>,
    #[serde(with = "optional", skip_serializing_if = "Option::is_none", default)]
    pub children_display: Option<String>,
}

impl MenuProperty {
    pub fn submenu() -> Self {
        MenuProperty {
            label: Some("root".to_owned()),
            children_display: Some("submenu".to_owned()),
            ..Default::default()
        }
    }
}

#[derive(Type, Debug, Default, Serialize, Deserialize, OwnedValue, Value)]
#[zvariant(signature = "(ia{sv}av)")]
pub struct MenuItem {
    pub id: i32,
    pub item: MenuProperty,
    pub sub_menus: Vec<zvariant::OwnedValue>,
}

#[derive(Clone, PartialEq, Type, Serialize, Deserialize, OwnedValue, Value, Debug, Default)]
#[zvariant(signature = "s", rename_all = "lowercase")]
pub enum MenuStatus {
    #[default]
    Normal,
    Notice,
    Disabled,
}
impl MenuItem {
    fn new() -> Self {
        MenuItem {
            id: 1,
            item: MenuProperty::submenu(),
            sub_menus: vec![],
        }
    }

    pub fn push_submenu(mut self, menu: MenuItem) -> Self {
        self.sub_menus.push(OwnedValue::try_from(menu).unwrap());
        self
    }
}

#[derive(Type, Debug, Default, Serialize, Deserialize)]
pub struct LayoutData {
    pub revision: u32,
    pub data: MenuItem,
}

#[derive(Type, Debug, Default, Serialize, Deserialize)]
pub struct PropertyItem {
    pub id: i32,
    pub item: MenuProperty,
}

pub trait DBusMenuItem {
    type State;

    fn boot(&self) -> Self::State;

    fn about_to_show(&self, state: &mut Self::State, id: i32) -> zbus::fdo::Result<bool>;

    #[allow(unused)]
    fn get_layout(
        &self,
        state: &mut Self::State,
        parent_id: i32,
        recursion_depth: i32,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<(u32, MenuItem)> {
        Ok((1, MenuItem::new()))
    }

    fn status(&self, _state: &Self::State) -> zbus::fdo::Result<MenuStatus> {
        Ok(MenuStatus::Normal)
    }

    #[allow(unused)]
    fn get_group_properties(
        &self,
        state: &mut Self::State,
        ids: Vec<i32>,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<Vec<PropertyItem>> {
        Ok(vec![])
    }

    #[allow(unused)]
    fn on_clicked(&self, state: &mut Self::State, id: i32, timestamp: u32) -> EventUpdate {
        EventUpdate::None
    }

    #[allow(unused)]
    fn on_toggled(
        &self,
        state: &mut Self::State,
        id: i32,
        status: ToggleStatus,
        timestamp: u32,
    ) -> EventUpdate {
        EventUpdate::None
    }
}

pub struct DBusMenuInstance<Menu: DBusMenuItem> {
    pub(crate) program: Menu,
    pub(crate) state: Menu::State,
}

pub trait DBusMenuBootFn<State> {
    fn boot(&self) -> State;
}

impl<T, State> DBusMenuBootFn<State> for T
where
    T: Fn() -> State,
{
    fn boot(&self) -> State {
        self()
    }
}

pub trait MenuStatusFn<State> {
    fn status(&self, state: &State) -> MenuStatus;
}

impl<T, State> MenuStatusFn<State> for T
where
    T: Fn(&State) -> MenuStatus,
{
    fn status(&self, state: &State) -> MenuStatus {
        self(state)
    }
}
pub trait AboutToShowFn<State> {
    fn about_to_show(&self, state: &mut State, id: i32) -> zbus::fdo::Result<bool>;
}

impl<T, State> AboutToShowFn<State> for T
where
    T: Fn(&mut State, i32) -> zbus::fdo::Result<bool>,
{
    fn about_to_show(&self, state: &mut State, id: i32) -> zbus::fdo::Result<bool> {
        self(state, id)
    }
}

pub trait GetLayoutFn<State> {
    fn get_layout(
        &self,
        state: &mut State,
        parent_id: i32,
        recursion_depth: i32,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<(u32, MenuItem)>;
}

impl<T, State> GetLayoutFn<State> for T
where
    T: Fn(&mut State, i32, i32, Vec<String>) -> zbus::fdo::Result<(u32, MenuItem)>,
{
    fn get_layout(
        &self,
        state: &mut State,
        parent_id: i32,
        recursion_depth: i32,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<(u32, MenuItem)> {
        self(state, parent_id, recursion_depth, property_names)
    }
}

pub trait GetGroupPropertiesFn<State> {
    fn get_group_properties(
        &self,
        state: &mut State,
        ids: Vec<i32>,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<Vec<PropertyItem>>;
}

impl<T, State> GetGroupPropertiesFn<State> for T
where
    T: Fn(&mut State, Vec<i32>, Vec<String>) -> zbus::fdo::Result<Vec<PropertyItem>>,
{
    fn get_group_properties(
        &self,
        state: &mut State,
        ids: Vec<i32>,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<Vec<PropertyItem>> {
        self(state, ids, property_names)
    }
}
#[derive(Debug)]
pub enum EventUpdate {
    None,
    Update { revision: u32, parent: i32 },
}

pub trait OnClickedFn<State> {
    fn on_clicked(&self, state: &mut State, id: i32, timestamp: u32) -> EventUpdate;
}

impl<T, State> OnClickedFn<State> for T
where
    T: Fn(&mut State, i32, u32) -> EventUpdate,
{
    fn on_clicked(&self, state: &mut State, id: i32, timestamp: u32) -> EventUpdate {
        self(state, id, timestamp)
    }
}

pub trait OnToggledFn<State> {
    fn on_toggled(
        &self,
        state: &mut State,
        id: i32,
        status: ToggleStatus,
        timestamp: u32,
    ) -> EventUpdate;
}

impl<T, State> OnToggledFn<State> for T
where
    T: Fn(&mut State, i32, ToggleStatus, u32) -> EventUpdate,
{
    fn on_toggled(
        &self,
        state: &mut State,
        id: i32,
        status: ToggleStatus,
        timestamp: u32,
    ) -> EventUpdate {
        self(state, id, status, timestamp)
    }
}

#[interface(name = "com.canonical.dbusmenu")]
impl<Menu: DBusMenuItem> DBusMenuInstance<Menu>
where
    Menu: Send + Sync + 'static,
    Menu::State: 'static + Send + Sync,
{
    fn about_to_show(&mut self, id: i32) -> zbus::fdo::Result<bool> {
        self.program.about_to_show(&mut self.state, id)
    }

    /// GetLayout method
    fn get_layout(
        &mut self,
        parent_id: i32,
        recursion_depth: i32,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<(u32, MenuItem)> {
        self.program
            .get_layout(&mut self.state, parent_id, recursion_depth, property_names)
    }

    /// GetGroupProperties method
    fn get_group_properties(
        &mut self,
        ids: Vec<i32>,
        property_names: Vec<String>,
    ) -> zbus::fdo::Result<Vec<PropertyItem>> {
        self.program
            .get_group_properties(&mut self.state, ids, property_names)
    }

    /// GetProperty method
    fn get_property(&self, _id: i32, _name: String) -> zbus::fdo::Result<OwnedValue> {
        Ok(true.into())
    }

    /// Version property
    #[zbus(property)]
    fn version(&self) -> zbus::fdo::Result<u32> {
        Ok(2)
    }

    /// Status property
    #[zbus(property)]
    fn status(&self) -> zbus::fdo::Result<MenuStatus> {
        self.program.status(&self.state)
    }

    /// Event method
    async fn event(
        &mut self,
        id: i32,
        event_id: String,
        data: zbus::zvariant::OwnedValue,
        timestamp: u32,
        #[zbus(object_server)] server: &zbus::ObjectServer,
    ) -> zbus::fdo::Result<()> {
        let need_update = match event_id.as_str() {
            "clicked" => self.program.on_clicked(&mut self.state, id, timestamp),
            "toggled" => {
                let status: ToggleStatus = data
                    .try_into()
                    .map_err(|e| zbus::fdo::Error::Failed(format!("data error: {e}")))?;
                self.program
                    .on_toggled(&mut self.state, id, status, timestamp)
            }
            _ => EventUpdate::None,
        };
        if let EventUpdate::Update { revision, parent } = need_update {
            let iface_rf = server
                .interface::<_, DBusMenuInstance<Menu>>("/MenuBar")
                .await?;
            let _ = DBusMenuInstance::<Menu>::layout_updated(
                iface_rf.signal_emitter(),
                revision,
                parent,
            )
            .await;
        }
        Ok(())
    }

    /// ItemActivationRequested signal
    #[zbus(signal)]
    pub async fn item_activation_requested(
        ctxt: &SignalEmitter<'_>,
        id: i32,
        timestamp: u32,
    ) -> zbus::Result<()>;

    /// ItemsPropertiesUpdated signal
    #[zbus(signal)]
    pub async fn items_properties_updated(
        ctxt: &SignalEmitter<'_>,
        updated_props: Vec<(
            i32,
            std::collections::HashMap<&str, zbus::zvariant::Value<'_>>,
        )>,
        removed_props: Vec<(i32, Vec<&str>)>,
    ) -> zbus::Result<()>;

    /// LayoutUpdated signal
    #[zbus(signal)]
    pub async fn layout_updated(
        ctxt: &SignalEmitter<'_>,
        revision: u32,
        parent: i32,
    ) -> zbus::Result<()>;
}

#[proxy(interface = "com.canonical.dbusmenu", default_path = "/MenuBar")]
pub trait dbusmenu {
    /// AboutToShowGroup method
    fn about_to_show_group(&self, ids: &[i32]) -> zbus::Result<(Vec<i32>, Vec<i32>)>;

    /// EventGroup method
    fn event_group(
        &self,
        events: &[&(i32, &str, &zbus::zvariant::Value<'_>, u32)],
    ) -> zbus::Result<Vec<i32>>;

    /// IconThemePath property
    #[zbus(property)]
    fn icon_theme_path(&self) -> zbus::Result<Vec<String>>;

    /// TextDirection property
    #[zbus(property)]
    fn text_direction(&self) -> zbus::Result<String>;
}
