//! # D-Bus interface proxy for: `com.canonical.dbusmenu`
//!
//! This code was generated by `zbus-xmlgen` `5.1.0` from D-Bus introspection data.
//! Source: `Interface '/MenuBar' from service ':1.9087' on system bus`.
//!
//! You may prefer to adapt it, instead of using it verbatim.
//!
//! More information can be found in the [Writing a client proxy] section of the zbus
//! documentation.
//!
//! This type implements the [D-Bus standard interfaces], (`org.freedesktop.DBus.*`) for which the
//! following zbus API can be used:
//!
//! * [`zbus::fdo::PropertiesProxy`]
//! * [`zbus::fdo::IntrospectableProxy`]
//! * [`zbus::fdo::PeerProxy`]
//!
//! Consequently `zbus-xmlgen` did not generate code for the above interfaces.
//!
//! [Writing a client proxy]: https://dbus2.github.io/zbus/client.html
//! [D-Bus standard interfaces]: https://dbus.freedesktop.org/doc/dbus-specification.html#standard-interfaces,
use serde::{Deserialize, Serialize};
use zbus::zvariant::{OwnedValue, Type, as_value};
use zbus::{interface, object_server::SignalEmitter, proxy};

#[derive(Type, Debug, Default, Serialize, Deserialize)]
/// Specified options for a [`Screencast::create_session`] request.
#[zvariant(signature = "dict")]
pub struct MenuData {
    #[serde(with = "as_value")]
    pub label: String,
    #[serde(with = "as_value")]
    pub enabled: bool,
}

// TODO: how to fix it
#[derive(Type, Debug, Default, Serialize, Deserialize)]
pub struct MenuItem {
    id: u32,
    item: MenuData,
    sub_menus: Vec<OwnedValue>,
}

pub trait DBusMenuItem {
    type State;

    fn boot(&self) -> Self::State;

    fn about_to_show(&self, state: &mut Self::State, id: i32) -> zbus::fdo::Result<bool>;
}

pub struct DBusMenuInstance<Menu: DBusMenuItem> {
    pub(crate) program: Menu,
    pub(crate) state: Menu::State,
}

pub trait DBusMenuBootFn<State> {
    fn boot(&self) -> State;
}

impl<T, State> DBusMenuBootFn<State> for T
where
    T: Fn() -> State,
{
    fn boot(&self) -> State {
        self()
    }
}

pub trait AboutToShowFn<State> {
    fn about_to_show(&self, state: &mut State, id: i32) -> zbus::fdo::Result<bool>;
}

impl<T, State> AboutToShowFn<State> for T
where
    T: Fn(&mut State, i32) -> zbus::fdo::Result<bool>,
{
    fn about_to_show(&self, state: &mut State, id: i32) -> zbus::fdo::Result<bool> {
        self(state, id)
    }
}

#[interface(name = "com.canonical.dbusmenu")]
impl<Menu: DBusMenuItem> DBusMenuInstance<Menu>
where
    Menu: Send + Sync + 'static,
    Menu::State: 'static + Send + Sync,
{
    fn about_to_show(&mut self, id: i32) -> zbus::fdo::Result<bool> {
        self.program.about_to_show(&mut self.state, id)
    }

    /// Version property
    #[zbus(property)]
    fn version(&self) -> zbus::fdo::Result<u32> {
        Ok(2)
    }

    /// Status property
    #[zbus(property)]
    fn status(&self) -> zbus::fdo::Result<String> {
        Ok("Active".to_owned())
    }

    /// ItemActivationRequested signal
    #[zbus(signal)]
    pub async fn item_activation_requested(
        ctxt: &SignalEmitter<'_>,
        id: i32,
        timestamp: u32,
    ) -> zbus::Result<()>;

    /// ItemsPropertiesUpdated signal
    #[zbus(signal)]
    pub async fn items_properties_updated(
        ctxt: &SignalEmitter<'_>,
        updated_props: Vec<(
            i32,
            std::collections::HashMap<&str, zbus::zvariant::Value<'_>>,
        )>,
        removed_props: Vec<(i32, Vec<&str>)>,
    ) -> zbus::Result<()>;

    /// LayoutUpdated signal
    #[zbus(signal)]
    pub async fn layout_updated(
        ctxt: &SignalEmitter<'_>,
        revision: u32,
        parent: i32,
    ) -> zbus::Result<()>;
}

#[proxy(interface = "com.canonical.dbusmenu", default_path = "/MenuBar")]
pub trait dbusmenu {
    /// AboutToShow method
    fn about_to_show(&self, id: i32) -> zbus::Result<bool>;

    /// AboutToShowGroup method
    fn about_to_show_group(&self, ids: &[i32]) -> zbus::Result<(Vec<i32>, Vec<i32>)>;

    /// Event method
    fn event(
        &self,
        id: i32,
        event_id: &str,
        data: &zbus::zvariant::Value<'_>,
        timestamp: u32,
    ) -> zbus::Result<()>;

    /// EventGroup method
    fn event_group(
        &self,
        events: &[&(i32, &str, &zbus::zvariant::Value<'_>, u32)],
    ) -> zbus::Result<Vec<i32>>;

    /// GetGroupProperties method
    fn get_group_properties(
        &self,
        ids: &[i32],
        property_names: &[&str],
    ) -> zbus::Result<
        Vec<(
            i32,
            std::collections::HashMap<String, zbus::zvariant::OwnedValue>,
        )>,
    >;

    /// GetLayout method
    fn get_layout(
        &self,
        parent_id: i32,
        recursion_depth: i32,
        property_names: &[&str],
    ) -> zbus::Result<(
        u32,
        (
            i32,
            std::collections::HashMap<String, zbus::zvariant::OwnedValue>,
            Vec<zbus::zvariant::OwnedValue>,
        ),
    )>;

    /// GetProperty method
    fn get_property(&self, id: i32, name: &str) -> zbus::Result<zbus::zvariant::OwnedValue>;

    /// IconThemePath property
    #[zbus(property)]
    fn icon_theme_path(&self) -> zbus::Result<Vec<String>>;

    /// Status property
    #[zbus(property)]
    fn status(&self) -> zbus::Result<String>;

    /// TextDirection property
    #[zbus(property)]
    fn text_direction(&self) -> zbus::Result<String>;
}
